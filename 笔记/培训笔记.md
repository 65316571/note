

```
一、ArrayList实现了可变大小的数组

二、LinkedList基于链表的实现
          ArrayList        LinkedList
添加       add()    		  add()  addFirst()    addLast()
查找       contains()      contains() 
取值       get(下标)        get(下标)  getFirst()   getLast()
删除       remove(下标)     remove(下标)    removeFirst() 
          remove(对象)      remove(对象) removeLast() 
长度        size()          size()

三、集合框架
             Collection接口---无序，不唯一        
             /       				   \
(有序，不唯一)List接口   			Set接口(无序，唯一)             
      	/        \                  /         \
  ArrayList     LinkedList         HashSet   TreeSet
实现可变大小的数组   基于链表的实现					排序好的数据
查找数据比较方便      插入删除数据方便

Collections 集合的帮助类

	Map接口--链值对存储
  /  		        \
 HashMap    		HashTable
键值都可以为null     键值都不可以为null 
 单线程实现    	      多线程的实现
  安全   		  	     不安全


ArrayList all=new ArrayList();
List list=new ArrayList();
Collection col=new ArrayList();

Map集合的存储【以键值对的形式出现】
键    值
张三   小三
李四  小四
王五  小五

HashMap中的常用方法：
添加     put(键,值)
删除     remove(键)
大小     size()
取值     get(键)
```





#### 树的基本术语：

若一个节点有子树，那么该节点称为子树根节点的“双亲“，子树的跟是该节点的“孩子”。有相同双亲的节点互为“兄弟节点”。一个节点的所有子树上的任何节点都是该节点的后裔。从根节点到某个节点的路径上的所有节点都是该节点的祖先。

1. 节点的度：节点拥有的子树的数目。
2. 叶子：度为零的节点。
3. 分支节点：度不为零的节点。
4. 树的度：树中节点的最大的度。
5. 层次：根节点的层次为1，其余节点的层次等于该节点的双亲节点加1。
6. 树的高度：树中节点的最大层次。
7. 无序数：如果树中节点的各子树之间的次序是不重要的，可以交换位置。
8. 有序数：如果树中结点的各子树的次序是重要的，不可以交换位置。
9. 森林：0个或多个不相交的树组成。对森林加上一个跟，森林即成为树；删去跟，树即成为森林。

```
递归算法三要素：
1、确定递归函数的参数和返回值：确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2、确定终止条件：写完了递归算法,  运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3、确定单层递归的逻辑：确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程

二叉树的性质:
1、高度为h的二叉树，最多有多少个节点：2的h次方-1
2、第i层最多有多少个节点: 2的(i-1)次方
3、n2=n0-1

四、二叉树的遍历
1、先根遍历法:根-左--右
首先访问根，然后访左子树（如果左子树只有一个节点，直接访问，如果超过一个节点，
那么以此节点为根继续先根遍历),然后访右子树（如果右子树只有一个节点，直接访问，如果超过一个节点，那么以此节点为根继续先根遍历)

2、中根遍历法:   左--根--右【中根最为重要！因为可以通过中根遍历法排序集合】
先访左子树（如果左子树只有一个节点，直接访问，如果超过一个节点，
那么以此节点为根继续中根遍历),然后访问根，然后访右子树（如果右子树只有一个节点，直接访问，如果超过一个节点，那么以此节点为根继续中根遍历)
3、后根遍历法:   左--右--根
先访左子树（如果左子树只有一个节点，直接访问，如果超过一个节点，
那么以此节点为根继续后根遍历),然后访右子树（如果右子树只有一个节点，直接访问，如果超过一个节点，那么以此节点为根继续后根遍历),访问根。
```



常用注解：

`@ResponseBody`：它将方法的返回值转换为指定的格式，如JSON或XML，并将其写入HTTP响应。

`@RequestMapping`：用于控制器类或处理方法上，并允许开发人员定义处理特定HTTP请求的方式（例如GET、POST等）以及请求的路径。

`@RequestParam`：用于从HTTP请求中提取请求参数的值，并将其绑定到方法的参数上。

![image-20240315141244162](C:\Data\Me\图片\Typora\image-20240315141244162.png)

`@DateTimeFormat`：用于指示Spring在将字符串转换为日期类型时使用的格式。

![image-20240315143001669](C:\Data\Me\图片\Typora\image-20240315143001669.png)

`@RestController`：结合了`@Controller`和`@ResponseBody`注解的功能，用于标识控制器类，其中的方法返回的对象将直接写入HTTP响应主体。

![image-20240320112945028](C:\Data\Me\图片\Typora\image-20240320112945028.png)

`@Controller`：用于标识一个类作为控制器，通常用于处理来自客户端的HTTP请求。控制器类中的方法通常负责处理请求，并返回相应的视图或数据。

`@Autowired：`用于自动装配Spring管理的Bean，它可以应用于字段、构造函数或方法上。

![image-20240320111454032](C:\Data\Me\图片\Typora\image-20240320111454032.png)

`@Service`：用于标识一个类作为服务层的组件。服务层通常包含应用程序的业务逻辑，如数据处理、数据验证、算法等。

![image-20240320112501319](C:\Data\Me\图片\Typora\image-20240320112501319.png)




# Linux常用命令组

clear 	 清空屏幕

date 	 系统查看时间

​		修改时间【date -s 'yyyy-MM-dd	hh-mm-ss'】

Ctrl+l		清屏【上滑可以看历史】

su		  切换用户

exit		退出当前用户

Tab 		补全

./命令文件.sh	执行Shell命令

Ctrl+c 	强制中断程序的执行

Ctrl+z 	将任务中止（暂停的意思）

### 文件上传（下载）	

sz：将选定的文件发送（send）到本地机器

rz：运行该命令会弹出一个文件选择窗口，从本地选择文件上传到Linux服务器

注：【Xshell独有】

### 移动文件：

mv   路径/文件名	移动后的路径/

mv   路径/文件名	移动后的路径/移动后的名字

### 压缩解压：

zip -r 压缩文件名字.zip /所选文件路径		[./即为当前目录所有文件]

unzip 解压文件名

tar -xvf 解压名字	

### 删除文件：

rm  -rf 删除名字

### 查看文件夹文件:

ll 查看文件（不包括隐藏文件）

ll -a 查看所有文件（包括隐藏文件）

### 搜索文件：

find  -@  -条件

@可以为：size、mtime、name、type

可以根据大小、时间、名字、类型

【使用前先切换到查询目录】

### 复制文件：

cp 文件名	复制文件

cp -a 文件名，选项a表示文件的属性也复制、目录下所有文件都复制

### 创建文件夹&删除文件夹

mkdir	新增名字

rzdir	删除名字

### 查看历史命令：

history							【查看历史】

### 开放端口号权限

/sbin/iptables -I INPUT -p tcp --dport 8080 -j ACCEPT			

# 常见问题以及解决

1、获取IP地址路径：如果ifconfig查询不出ip地址

输入：sudo dhclient ens33	【重新获取IP】

- dhclient -r ens33 # 释放IP
- dhclient ens33 # 获取IP






阐述一下SpringBoot：

Spring Boot 是 Pivotal 团队开发的一款装箱即用的框架，其设计理念主要体现在两个方面：约定大于配置和自动化配置。

1. 约定大于配置：Spring Boot 采用了约定大于配置的设计理念，通过事先定义好的约定来规范应用的开发，减少了开发者需要手动配置的工作量。这意味着在遵循框架约定的情况下，开发者可以不必手动配置大量的参数和组件，而是直接开始编写业务逻辑。这种设计方式使得开发者可以更加专注于业务逻辑的实现，而不必过多关注框架配置的细节，从而提高了开发效率和代码质量。
2. 自动化配置：Spring Boot 提供了丰富的自动化配置功能，能够根据应用的依赖关系和环境自动配置所需的组件和参数。这意味着开发者无需手动配置大部分的应用组件，Spring Boot 可以自动识别应用的需求并进行相应的配置。例如，当应用引入了数据库依赖时，Spring Boot 可以自动配置数据库连接池、数据源等相关组件，大大简化了应用的配置过程。

通过约定大于配置和自动化配置这两个核心设计理念，Spring Boot 实现了快速、简单和高效的应用开发。开发者只需引入 Spring Boot Starter 模块并遵循框架的约定，即可快速搭建起一个可运行的应用程序。这种装箱即用的设计使得 Spring Boot 成为了Java开发领域中最受欢迎的框架之一，被广泛应用于各种类型的企业级应用开发中。

阿里云镜像：**https://start.aliyun.com**



启动类：@SpringBootApplication 

它实际上是三个注解的组合：`@Configuration`、`@EnableAutoConfiguration` 和 `@ComponentScan`。

以下是这些注解的功能解析：

1. `@Configuration`：这个注解表示类是应用程序上下文的配置类。它允许在类内部使用 `@Bean` 方法来定义 bean。
2. `@EnableAutoConfiguration`：这个注解启用了 Spring Boot 的自动配置机制。它会根据应用程序的依赖项和类路径自动配置 Spring 应用程序。Spring Boot 分析类路径，并根据需要自动配置 Spring 应用程序。
3. `@ComponentScan`：这个注解告诉 Spring 在指定的包及其子包中扫描 Spring 组件（例如 `@Component`、`@Service`、`@Repository`、`@Controller` 等），并自动将它们注册为 Spring Bean。

当你使用 `@SpringBootApplication` 时，实际上是将这三个注解的功能合并到一个方便的注解中。

2024/4/18：

Vue的指令：

| 指令    | 描述                                             | 示例                                                 |
| ------- | ------------------------------------------------ | ---------------------------------------------------- |
| v-if    | 根据条件添加或移除DOM元素                        | `<div v-if="isShow">内容</div>`                      |
| v-for   | 遍历数组或对象，生成对应数量的DOM元素            | `<ul><li v-for="item in items">{{ item }}</li></ul>` |
| v-model | 实现表单元素与Vue实例数据的双向绑定              | `<input type="text" v-model="message">`              |
| v-on    | 绑定事件监听器，执行对应的Vue实例方法或表达式    | `<button v-on:click="handleClick">点击按钮</button>` |
| v-bind  | 动态地绑定HTML属性或组件的props                  | `<img v-bind:src="imageUrl">`                        |
| v-show  | 根据条件显示或隐藏DOM元素（通过修改display属性） | `<div v-show="isShow">内容</div>`                    |
| v-once  | 只渲染元素和组件一次                             | `<span v-once>{{ staticContent }}</span>`            |
| v-pre   | 跳过当前元素及其子元素的编译过程                 | `<div v-pre>{{ 不会被编译的内容 }}</div>`            |
| v-cloak | 解决初始渲染时出现闪烁的问题（保持元素隐藏）     | `<div v-cloak>{{ message }}</div>`                   |

补充：DOM元素就当前操作节点的元素

v-on 可以简写成  @

v-bind 可以简写成 :



Vue的生命周期：

有多个生命周期 但只选择两个常用的：

mounted(){

//页面加载完成事件

}

created(){

//组件在内存中完毕事件

}



Vue组件：

常用组件

| 选项            | 作用                                                       |
| --------------- | ---------------------------------------------------------- |
| `data`          | 定义组件的响应式数据                                       |
| `props`         | 接收父组件传递过来的数据                                   |
| `computed`      | 定义计算属性，根据依赖的响应式数据进行计算                 |
| `methods`       | 定义组件中可复用的方法                                     |
| `watch`         | 监听数据的变化，并在数据变化时执行相应的操作               |
| `created`       | 在组件实例被创建后立即调用，用于初始化操作                 |
| `mounted`       | 在组件被挂载到 DOM 后调用，用于执行 DOM 操作等             |
| `beforeUpdate`  | 在数据更新之前调用，可以访问更新前的状态但尚未重新渲染 DOM |
| `updated`       | 在数据更新之后调用，可以执行一些 DOM 操作但需避免触发更新  |
| `beforeDestroy` | 在组件销毁之前调用，用于执行一些清理工作                   |
| `destroyed`     | 在组件销毁之后调用，用于执行最终的清理工作                 |
| `directives`    | 自定义指令，用于封装 DOM 操作或者行为                      |
| `filters`       | 自定义过滤器，用于格式化文本或者数据                       |
| `mixins`        | 混入对象，用于在多个组件之间共享代码逻辑                   |
| `components`    | 注册子组件，使其可以在父组件模板中使                       |



